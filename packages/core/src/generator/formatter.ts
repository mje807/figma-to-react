/**
 * generator/formatter.ts
 * 생성된 코드 포맷팅 (Prettier 통합)
 *
 * Prettier가 설치되어 있지 않을 때는 기본 포매터 사용 (들여쓰기 정규화만)
 */

import { logger } from '../utils/logger.js';

export type FileType = 'tsx' | 'ts' | 'css' | 'json';

// ─── Prettier 타입 (선택적 설치) ────────────────────────────────────────────

interface PrettierLike {
  format(source: string, options?: Record<string, unknown>): Promise<string>;
}

let prettierCache: PrettierLike | null | undefined = undefined; // undefined = 미확인

async function getPrettier(): Promise<PrettierLike | null> {
  if (prettierCache !== undefined) return prettierCache;

  try {
    // prettier는 선택적 의존성 — 설치 안 되어 있으면 기본 포매터 사용
    const moduleName = 'prettier';
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const m = await (import(/* @vite-ignore */ moduleName) as Promise<any>);
    prettierCache = m as PrettierLike;
  } catch {
    logger.debug('Prettier 미설치. 기본 포매터 사용.');
    prettierCache = null;
  }

  return prettierCache;
}

// ─── 메인 포맷터 ─────────────────────────────────────────────────────────────

/**
 * 코드 문자열 포맷팅
 * Prettier 사용 가능하면 Prettier, 없으면 기본 포매터
 */
export async function formatCode(
  code: string,
  fileType: FileType = 'tsx',
): Promise<string> {
  const prettier = await getPrettier();

  if (prettier) {
    try {
      const parserMap: Record<FileType, string> = {
        tsx: 'babel-ts',
        ts: 'babel-ts',
        css: 'css',
        json: 'json',
      };

      return await prettier.format(code, {
        parser: parserMap[fileType],
        semi: true,
        singleQuote: true,
        trailingComma: 'all',
        printWidth: 100,
        tabWidth: 2,
        bracketSpacing: true,
        arrowParens: 'avoid',
      });
    } catch (err) {
      logger.warn(`Prettier 포맷팅 실패: ${(err as Error).message}. 기본 포매터로 대체.`);
    }
  }

  return basicFormat(code, fileType);
}

/**
 * 여러 파일 동시 포맷팅
 */
export async function formatFiles(
  files: Map<string, string>,
): Promise<Map<string, string>> {
  const result = new Map<string, string>();

  for (const [filename, content] of files) {
    const fileType = detectFileType(filename);
    const formatted = await formatCode(content, fileType);
    result.set(filename, formatted);
  }

  return result;
}

// ─── 기본 포매터 (Prettier 없을 때) ──────────────────────────────────────────

/**
 * 최소한의 코드 정규화:
 * - 연속 빈 줄 → 최대 1개
 * - 파일 끝 개행 보장
 * - import 구문 뒤 빈 줄 보장
 */
export function basicFormat(code: string, fileType: FileType = 'tsx'): string {
  if (fileType === 'json') {
    try {
      return JSON.stringify(JSON.parse(code), null, 2) + '\n';
    } catch {
      return code;
    }
  }

  let result = code
    // 연속 빈 줄 → 최대 1개
    .replace(/\n{3,}/g, '\n\n')
    // import 블록 뒤 빈 줄 보장
    .replace(/(import [^\n]+\n)(export|const|function|interface|type|class)/g, '$1\n$2')
    // 파일 시작 빈 줄 제거
    .replace(/^\n+/, '');

  // 파일 끝 개행 보장
  if (!result.endsWith('\n')) result += '\n';

  return result;
}

// ─── Helpers ─────────────────────────────────────────────────────────────────

function detectFileType(filename: string): FileType {
  if (filename.endsWith('.tsx')) return 'tsx';
  if (filename.endsWith('.ts')) return 'ts';
  if (filename.endsWith('.css')) return 'css';
  if (filename.endsWith('.json')) return 'json';
  return 'ts';
}

// ─── 코드 생성 주석 추가 ─────────────────────────────────────────────────────

/**
 * 파일 상단에 생성 주석 추가
 */
export function addGenerationComment(
  code: string,
  options: {
    tool?: string;
    figmaFile?: string;
    timestamp?: string;
    editNote?: string;
  } = {},
): string {
  const {
    tool = 'figma-to-react',
    figmaFile,
    timestamp = new Date().toISOString(),
    editNote = 'Do not edit manually — regenerate with f2r',
  } = options;

  const lines = [
    `/**`,
    ` * Generated by ${tool}`,
    figmaFile ? ` * Source: ${figmaFile}` : null,
    ` * Generated: ${timestamp}`,
    ` * ${editNote}`,
    ` */`,
    '',
  ].filter((l): l is string => l !== null);

  return lines.join('\n') + code;
}
