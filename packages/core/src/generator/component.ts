/**
 * generator/component.ts
 * Phase 4 메인 오케스트레이터 — IRNode → 완전한 React 컴포넌트 파일 생성
 *
 * 출력 파일 구조:
 * ComponentName.tsx  — 컴포넌트 구현
 * ComponentName.module.css  — CSS Modules (해당 시)
 * types.ts           — Props 타입 정의
 * index.ts           — barrel export
 */

import type { IRNode } from '../ir/types.js';
import type { StyleAdapter } from '../adapters/base.js';
import { JsxBuilder, type JsxBuilderOptions } from './jsx-builder.js';
import { generatePropsInterface, generateDefaultPropsInterface } from './types-gen.js';
import { ImportResolver } from './import-resolver.js';
import { generateBarrelFile, type BarrelEntry } from './barrel.js';
import { formatCode, addGenerationComment } from './formatter.js';

// ─── 타입 ─────────────────────────────────────────────────────────────────────

export interface GenerateOptions {
  /** 스타일 어댑터 */
  adapter: StyleAdapter;
  /** 생성 파일에 Prettier 포맷팅 적용 */
  format?: boolean;
  /** 생성 주석 포함 */
  includeComment?: boolean;
  /** Figma 파일명 (주석용) */
  figmaFile?: string;
  /** 아이콘 라이브러리 (예: 'lucide-react') */
  iconLibrary?: string;
  /** 에셋 경로 맵 */
  assetPathMap?: Map<string, string>;
  /** 경고 주석 포함 */
  includeWarnings?: boolean;
}

export interface GeneratedFile {
  /** 파일 이름 (확장자 포함, 경로 없음) */
  filename: string;
  /** 파일 내용 */
  content: string;
}

export interface GeneratedComponent {
  /** 컴포넌트 이름 (PascalCase) */
  name: string;
  /** 생성된 파일 목록 */
  files: GeneratedFile[];
}

// ─── ComponentGenerator ──────────────────────────────────────────────────────

export class ComponentGenerator {
  private opts: Required<GenerateOptions>;

  constructor(options: GenerateOptions) {
    this.opts = {
      format: true,
      includeComment: true,
      figmaFile: '',
      iconLibrary: '',
      assetPathMap: new Map(),
      includeWarnings: false,
      ...options,
    };
  }

  /**
   * 단일 IRNode → GeneratedComponent (여러 파일)
   */
  async generate(node: IRNode): Promise<GeneratedComponent> {
    const componentName = node.name;
    const files: GeneratedFile[] = [];

    // 1. 타입 파일
    const typesContent = this.generateTypesFile(node);
    files.push({ filename: 'types.ts', content: await this.finalize(typesContent, 'ts') });

    // 2. 메인 컴포넌트 파일 (.tsx)
    const componentContent = this.generateComponentFile(node, componentName);
    files.push({
      filename: `${componentName}.tsx`,
      content: await this.finalize(componentContent, 'tsx'),
    });

    // 3. CSS Modules 파일 (해당 어댑터 시)
    if (this.opts.adapter.requiresSeparateFile()) {
      const cssContent = this.opts.adapter.generateStyleFile([node]) ?? '';
      if (cssContent) {
        files.push({
          filename: `${componentName}.module.css`,
          content: await this.finalize(cssContent, 'css'),
        });
      }
    }

    // 4. barrel 파일
    const barrelEntry: BarrelEntry = {
      componentName,
      filePath: `./${componentName}`,
    };
    const barrelContent = generateBarrelFile([barrelEntry]);
    files.push({ filename: 'index.ts', content: await this.finalize(barrelContent, 'ts') });

    return { name: componentName, files };
  }

  /**
   * 여러 IRNode → barrel export를 포함한 전체 파일 세트
   */
  async generateAll(nodes: IRNode[]): Promise<{
    components: GeneratedComponent[];
    barrel: GeneratedFile;
  }> {
    const components: GeneratedComponent[] = [];
    const barrelEntries: BarrelEntry[] = [];

    for (const node of nodes) {
      const comp = await this.generate(node);
      components.push(comp);
      barrelEntries.push({
        componentName: node.name,
        filePath: `./${node.name}/${node.name}`,
      });
    }

    const barrelContent = generateBarrelFile(barrelEntries);
    const barrel: GeneratedFile = {
      filename: 'index.ts',
      content: await this.finalize(barrelContent, 'ts'),
    };

    return { components, barrel };
  }

  // ─── 내부: 타입 파일 생성 ─────────────────────────────────────────────────

  private generateTypesFile(node: IRNode): string {
    const lines = [
      `// Generated by figma-to-react — Do not edit manually`,
      `import type React from 'react';`,
      '',
    ];

    if (node.props && node.props.length > 0) {
      lines.push(generatePropsInterface(node.name, node.props, true));
    } else {
      lines.push(generateDefaultPropsInterface(node.name));
    }

    lines.push('');
    return lines.join('\n');
  }

  // ─── 내부: 컴포넌트 파일 생성 ────────────────────────────────────────────

  private generateComponentFile(node: IRNode, componentName: string): string {
    // import 분석
    const resolverOpts: { outputDir?: string; iconLibrary?: string } = {};
    if (this.opts.iconLibrary) resolverOpts.iconLibrary = this.opts.iconLibrary;

    const resolver = new ImportResolver(this.opts.adapter, resolverOpts);
    const imports = resolver.resolve(node, componentName);

    // JSX 생성
    const jsxOpts: JsxBuilderOptions = {
      adapter: this.opts.adapter,
      assetPathMap: this.opts.assetPathMap,
      includeWarnings: this.opts.includeWarnings,
      expandRepeating: true,
    };
    const builder = new JsxBuilder(jsxOpts);
    const jsxBody = builder.build(node, 1);

    // Props 타입 결정
    const propsType = `${componentName}Props`;

    // 컴포넌트 함수 생성
    const sections = [
      imports.toString(),
      '',
      `export function ${componentName}({ className, ...props }: ${propsType}) {`,
      `  return (`,
      jsxBody,
      `  );`,
      `}`,
      '',
    ];

    return sections.join('\n');
  }

  // ─── 내부: 파일 완성 (포맷팅 + 주석) ─────────────────────────────────────

  private async finalize(content: string, fileType: 'tsx' | 'ts' | 'css' | 'json'): Promise<string> {
    let result = content;

    if (this.opts.includeComment && fileType !== 'css') {
      const commentOpts: Parameters<typeof addGenerationComment>[1] = {};
      if (this.opts.figmaFile) commentOpts.figmaFile = this.opts.figmaFile;
      result = addGenerationComment(result, commentOpts);
    }

    if (this.opts.format) {
      result = await formatCode(result, fileType);
    }

    return result;
  }
}

// ─── 편의 함수 ───────────────────────────────────────────────────────────────

/**
 * 단일 노드 → 컴포넌트 파일 내용 문자열 (Map 형태)
 * 간단한 사용 사례용
 */
export async function generateComponent(
  node: IRNode,
  adapter: StyleAdapter,
  options: Partial<GenerateOptions> = {},
): Promise<Map<string, string>> {
  const generator = new ComponentGenerator({ adapter, ...options });
  const result = await generator.generate(node);

  const fileMap = new Map<string, string>();
  for (const file of result.files) {
    fileMap.set(file.filename, file.content);
  }
  return fileMap;
}
