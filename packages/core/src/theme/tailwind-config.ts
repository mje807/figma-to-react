/**
 * theme/tailwind-config.ts
 * DesignTokens → tailwind.config.js / tailwind.config.ts extend 섹션 생성
 *
 * 2가지 출력:
 * 1. tailwind.config.js 전체 파일 (standalone)
 * 2. extend 섹션만 (기존 config에 병합용)
 */

import type { DesignTokens } from '../ir/types.js';

// ─── 전체 tailwind.config.js 생성 ────────────────────────────────────────────

export function generateTailwindConfig(tokens: DesignTokens): string {
  const extend = buildExtendSection(tokens);

  return [
    '/** @type {import("tailwindcss").Config} */',
    '// Generated by figma-to-react — customize as needed',
    'module.exports = {',
    "  content: ['./src/**/*.{ts,tsx}', './app/**/*.{ts,tsx}'],",
    '  theme: {',
    '    extend: {',
    ...formatExtend(extend, 6),
    '    },',
    '  },',
    '  plugins: [],',
    '};',
  ].join('\n');
}

// ─── extend 섹션만 생성 (TypeScript 포맷) ────────────────────────────────────

export function generateTailwindExtend(tokens: DesignTokens): string {
  const extend = buildExtendSection(tokens);

  return [
    '// figma-to-react generated extend — paste into tailwind.config.ts',
    'const figmaExtend = {',
    ...formatExtend(extend, 2),
    '} as const;',
    '',
    'export default figmaExtend;',
  ].join('\n');
}

// ─── 내부: extend 객체 빌드 ──────────────────────────────────────────────────

interface TailwindExtend {
  colors?: Record<string, string | Record<string, string>>;
  spacing?: Record<string, string>;
  borderRadius?: Record<string, string>;
  fontFamily?: Record<string, string[]>;
  fontSize?: Record<string, [string, { lineHeight: string; fontWeight?: string }]>;
  screens?: Record<string, string>;
  boxShadow?: Record<string, string>;
}

function buildExtendSection(tokens: DesignTokens): TailwindExtend {
  const extend: TailwindExtend = {};

  // ── Colors ──
  if (Object.keys(tokens.colors).length > 0) {
    const twColors: Record<string, Record<string, string>> = {};
    for (const [group, shades] of Object.entries(tokens.colors)) {
      twColors[group] = {};
      for (const [shade, value] of Object.entries(shades)) {
        const key = shade === 'DEFAULT' ? 'DEFAULT' : shade;
        twColors[group][key] = value;
      }
    }
    extend.colors = twColors as Record<string, Record<string, string>>;
  }

  // ── Spacing ──
  if (Object.keys(tokens.spacing).length > 0) {
    extend.spacing = {};
    for (const [key, px] of Object.entries(tokens.spacing)) {
      extend.spacing[`f-${key}`] = `${px}px`; // prefix로 충돌 방지
    }
  }

  // ── Border Radius ──
  if (Object.keys(tokens.borderRadius).length > 0) {
    extend.borderRadius = {};
    for (const [key, px] of Object.entries(tokens.borderRadius)) {
      extend.borderRadius[key === 'DEFAULT' ? 'f-base' : `f-${key}`] = `${px}px`;
    }
  }

  // ── Typography → fontFamily + fontSize ──
  if (Object.keys(tokens.typography).length > 0) {
    extend.fontFamily = {};
    extend.fontSize = {};
    for (const [name, style] of Object.entries(tokens.typography)) {
      if (style.fontFamily && style.fontFamily !== 'sans-serif') {
        extend.fontFamily[name] = [style.fontFamily, 'sans-serif'];
      }
      extend.fontSize[name] = [
        `${style.fontSize}px`,
        {
          lineHeight: `${style.lineHeight}`,
          fontWeight: String(style.fontWeight),
        },
      ];
    }
  }

  // ── Breakpoints ──
  if (Object.keys(tokens.breakpoints).length > 0) {
    extend.screens = {};
    for (const [key, px] of Object.entries(tokens.breakpoints)) {
      extend.screens[key] = `${px}px`;
    }
  }

  // ── Shadows ──
  if (Object.keys(tokens.shadows).length > 0) {
    extend.boxShadow = {};
    for (const [key, value] of Object.entries(tokens.shadows)) {
      extend.boxShadow[`f-${key}`] = value;
    }
  }

  return extend;
}

// ─── 포매터 ──────────────────────────────────────────────────────────────────

function formatExtend(extend: TailwindExtend, indent: number): string[] {
  const pad = ' '.repeat(indent);
  const lines: string[] = [];

  for (const [section, value] of Object.entries(extend)) {
    if (!value || typeof value !== 'object') continue;
    lines.push(`${pad}${section}: {`);
    formatValue(value, indent + 2, lines);
    lines.push(`${pad}},`);
  }

  return lines;
}

function formatValue(
  obj: unknown,
  indent: number,
  lines: string[],
): void {
  const pad = ' '.repeat(indent);

  if (Array.isArray(obj)) {
    lines.push(`${JSON.stringify(obj)},`);
    return;
  }

  if (obj && typeof obj === 'object') {
    for (const [k, v] of Object.entries(obj as Record<string, unknown>)) {
      if (Array.isArray(v)) {
        lines.push(`${pad}'${k}': ${JSON.stringify(v)},`);
      } else if (v && typeof v === 'object') {
        lines.push(`${pad}'${k}': {`);
        formatValue(v, indent + 2, lines);
        lines.push(`${pad}},`);
      } else {
        lines.push(`${pad}'${k}': '${v}',`);
      }
    }
  }
}
