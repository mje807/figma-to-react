/**
 * adapters/css-modules.ts
 * IRNode → CSS Modules (.module.css) 규칙 생성
 *
 * 각 노드마다 고유 클래스명 생성 → .module.css 파일에 규칙 추가
 * JSX에서는 `import styles from './Component.module.css'` 후
 * className={styles.container} 형태로 사용
 */

import type { IRNode } from '../ir/types.js';
import type { StyleOutput, StyleAdapter } from './base.js';
import type { DesignTokens } from '../ir/types.js';
import {
  backgroundToCss,
  shadowToCss,
  borderRadiusToCss,
  sizeToCss,
  irColorToRgba,
} from './token-mapper.js';
import { DEFAULT_TOKENS } from '../theme/extractor.js';
import { toKebabCase } from '../utils/naming.js';

// ─── CssModulesAdapter ───────────────────────────────────────────────────────

export class CssModulesAdapter implements StyleAdapter {
  readonly name = 'css-modules';
  private tokens: DesignTokens;
  /** 생성된 클래스 → CSS 규칙 맵 (generateStyleFile에서 사용) */
  private collectedRules = new Map<string, string>();

  constructor(tokens: DesignTokens = DEFAULT_TOKENS) {
    this.tokens = tokens;
  }

  generateStyle(node: IRNode): StyleOutput {
    const className = nodeToClassName(node);
    const cssRules = this.buildCssRules(node);

    if (Object.keys(cssRules).length > 0) {
      this.collectedRules.set(className, cssRulesToString(cssRules));
    }

    return {
      inlineProps: { className: `{styles.${className}}` },
      styleRules: { [className]: cssRulesToString(cssRules) },
    };
  }

  getImports(): string[] {
    return [`import styles from './[ComponentName].module.css';`];
  }

  requiresSeparateFile(): boolean {
    return true;
  }

  generateStyleFile(nodes: IRNode[]): string {
    // 모든 노드 스타일 수집
    nodes.forEach(node => this.collectAll(node));

    const rules = [...this.collectedRules.entries()]
      .map(([cls, rule]) => `.${cls} {\n${rule}\n}`)
      .join('\n\n');

    return `/* Generated by figma-to-react */\n\n${rules}\n`;
  }

  // ─── CSS 규칙 생성 ──────────────────────────────────────────────────────

  private buildCssRules(node: IRNode): Record<string, string> {
    const rules: Record<string, string> = {};
    const { layout, style } = node;

    // ── Layout ──
    rules['display'] = layout.display;
    if (layout.direction) rules['flex-direction'] = layout.direction;
    if (layout.wrap)      rules['flex-wrap'] = 'wrap';
    if (layout.justify)   rules['justify-content'] = layout.justify;
    if (layout.align)     rules['align-items'] = layout.align;

    if (layout.position !== 'static') {
      rules['position'] = layout.position;
    }
    if (layout.top !== undefined)    rules['top']    = `${layout.top}px`;
    if (layout.right !== undefined)  rules['right']  = `${layout.right}px`;
    if (layout.bottom !== undefined) rules['bottom'] = `${layout.bottom}px`;
    if (layout.left !== undefined)   rules['left']   = `${layout.left}px`;

    if (layout.gap !== undefined)    rules['gap']    = `${layout.gap}px`;

    if (layout.padding) {
      const [t, r, b, l] = layout.padding;
      rules['padding'] = `${t}px ${r}px ${b}px ${l}px`;
    }

    const w = sizeToCss(layout.width,  'width');
    const h = sizeToCss(layout.height, 'height');
    if (w) rules['width']  = w;
    if (h) rules['height'] = h;

    // ── Style ──
    if (style.background) {
      const bg = backgroundToCss(style.background);
      if (bg) {
        // 이미지 또는 그라디언트면 background, 단색이면 background-color
        if (style.background.type === 'solid') {
          rules['background-color'] = bg;
        } else {
          rules['background'] = bg;
        }
      }
    }

    if (style.border) {
      const { border } = style;
      rules['border'] = `${border.width}px solid ${irColorToRgba(border.color)}`;
      if (border.position === 'inside')  rules['box-sizing'] = 'border-box';
      if (border.position === 'outside') rules['box-sizing'] = 'content-box';
    }

    if (style.borderRadius !== undefined) {
      rules['border-radius'] = borderRadiusToCss(style.borderRadius);
    }

    if (style.shadow?.length) {
      rules['box-shadow'] = shadowToCss(style.shadow);
    }

    if (style.opacity !== undefined) {
      rules['opacity'] = String(style.opacity);
    }

    if (style.overflow) {
      rules['overflow'] = style.overflow;
    }

    // ── Font (텍스트 노드) ──
    if (style.font) {
      const { font } = style;
      rules['font-family']  = `'${font.family}', sans-serif`;
      rules['font-size']    = `${font.size}px`;
      rules['font-weight']  = String(font.weight);
      if (font.lineHeight !== 'auto') {
        rules['line-height'] = `${font.lineHeight}px`;
      }
      if (font.letterSpacing !== 0) {
        rules['letter-spacing'] = `${font.letterSpacing}px`;
      }
      rules['text-align'] = font.align;
      if (font.decoration && font.decoration !== 'none') {
        rules['text-decoration'] = font.decoration === 'line-through'
          ? 'line-through'
          : font.decoration;
      }
      if (font.transform && font.transform !== 'none') {
        rules['text-transform'] = font.transform;
      }
    }

    // CSS 변수 (디자인 토큰 참조가 있을 경우 덮어씀)
    this.applyTokenRefs(node, rules);

    return rules;
  }

  private applyTokenRefs(node: IRNode, rules: Record<string, string>): void {
    // IRColor.tokenRef → CSS 변수로 치환
    const bg = node.style.background;
    if (bg?.type === 'solid' && bg.tokenRef) {
      rules['background-color'] = `var(--${bg.tokenRef.replace(/\./g, '-')})`;
    }
    if (node.style.font?.tokenRef) {
      rules['font'] = `var(--${node.style.font.tokenRef.replace(/\./g, '-')})`;
    }
  }

  private collectAll(node: IRNode): void {
    this.generateStyle(node);
    for (const child of node.children) {
      this.collectAll(child);
    }
  }

  /** 중간 수집 결과 초기화 (재사용 시) */
  reset(): void {
    this.collectedRules.clear();
  }

  /** 현재까지 수집된 CSS 규칙 반환 */
  getCollectedRules(): Map<string, string> {
    return new Map(this.collectedRules);
  }

  // 사용 안 된 tokens 참조 유지
  private _tokens(): DesignTokens { return this.tokens; }
}

// ─── Helpers ─────────────────────────────────────────────────────────────────

function nodeToClassName(node: IRNode): string {
  // PascalCase 이름 → camelCase 클래스명
  const base = toKebabCase(node.name).replace(/-+/g, '-').replace(/^-|-$/g, '');
  return base || `node-${node.id}`;
}

function cssRulesToString(rules: Record<string, string>): string {
  return Object.entries(rules)
    .filter(([, v]) => v !== '')
    .map(([k, v]) => `  ${k}: ${v};`)
    .join('\n');
}
