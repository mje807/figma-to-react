import { describe, it, expect, beforeEach } from 'vitest';
import { CssModulesAdapter } from '../../adapters/css-modules.js';
import { parseNode } from '../../parser/node-parser.js';
import type { FigmaNode } from '../../parser/figma-client.js';

function makeNode(overrides: Partial<FigmaNode> = {}): FigmaNode {
  return {
    id: '1:1',
    name: 'Card',
    type: 'FRAME',
    absoluteBoundingBox: { x: 0, y: 0, width: 320, height: 200 },
    ...overrides,
  };
}

describe('CssModulesAdapter', () => {
  let adapter: CssModulesAdapter;

  beforeEach(() => {
    adapter = new CssModulesAdapter();
  });

  it('flex 레이아웃 → CSS display:flex', () => {
    const ir = parseNode(makeNode({
      layoutMode: 'HORIZONTAL',
      primaryAxisAlignItems: 'CENTER',
      counterAxisAlignItems: 'CENTER',
    }));
    const { styleRules } = adapter.generateStyle(ir);
    const css = Object.values(styleRules ?? {}).join('\n');
    expect(css).toContain('display: flex');
    expect(css).toContain('justify-content: center');
    expect(css).toContain('align-items: center');
  });

  it('flex-direction column', () => {
    const ir = parseNode(makeNode({ layoutMode: 'VERTICAL' }));
    const { styleRules } = adapter.generateStyle(ir);
    const css = Object.values(styleRules ?? {}).join('\n');
    expect(css).toContain('flex-direction: column');
  });

  it('배경색 → background-color', () => {
    const ir = parseNode(makeNode({
      fills: [{ type: 'SOLID', color: { r: 0, g: 0.47, b: 1, a: 1 } }],
    }));
    const { styleRules } = adapter.generateStyle(ir);
    const css = Object.values(styleRules ?? {}).join('\n');
    expect(css).toContain('background-color:');
  });

  it('border → border 단축 속성', () => {
    const ir = parseNode(makeNode({
      strokes: [{ type: 'SOLID', color: { r: 0, g: 0, b: 0, a: 1 } }],
      strokeWeight: 2,
      strokeAlign: 'CENTER',
    }));
    const { styleRules } = adapter.generateStyle(ir);
    const css = Object.values(styleRules ?? {}).join('\n');
    expect(css).toContain('border: 2px solid');
  });

  it('cornerRadius → border-radius', () => {
    const ir = parseNode(makeNode({ cornerRadius: 12 }));
    const { styleRules } = adapter.generateStyle(ir);
    const css = Object.values(styleRules ?? {}).join('\n');
    expect(css).toContain('border-radius: 12px');
  });

  it('padding → padding 단축 속성', () => {
    const ir = parseNode(makeNode({
      layoutMode: 'HORIZONTAL',
      paddingTop: 8, paddingRight: 16, paddingBottom: 8, paddingLeft: 16,
    }));
    const { styleRules } = adapter.generateStyle(ir);
    const css = Object.values(styleRules ?? {}).join('\n');
    expect(css).toContain('padding: 8px 16px 8px 16px');
  });

  it('inlineProps → className 포함', () => {
    const ir = parseNode(makeNode());
    const { inlineProps } = adapter.generateStyle(ir);
    expect(inlineProps['className']).toContain('styles.');
  });

  it('requiresSeparateFile → true', () => {
    expect(adapter.requiresSeparateFile()).toBe(true);
  });

  it('getImports → CSS Modules import 포함', () => {
    const imports = adapter.getImports();
    expect(imports.some(i => i.includes('.module.css'))).toBe(true);
  });

  it('텍스트 노드 → font-family, font-size', () => {
    const ir = parseNode(makeNode({
      type: 'TEXT',
      name: 'Heading',
      characters: 'Hello',
      style: { fontFamily: 'Pretendard', fontWeight: 700, fontSize: 24 },
    }));
    const { styleRules } = adapter.generateStyle(ir);
    const css = Object.values(styleRules ?? {}).join('\n');
    expect(css).toContain("font-family: 'Pretendard'");
    expect(css).toContain('font-size: 24px');
    expect(css).toContain('font-weight: 700');
  });

  it('generateStyleFile → :root comment 포함', () => {
    const ir = parseNode(makeNode());
    adapter.generateStyle(ir); // 규칙 수집
    const file = adapter.generateStyleFile([]);
    expect(file).toContain('Generated by figma-to-react');
  });

  it('reset() 후 수집 초기화', () => {
    const ir = parseNode(makeNode());
    adapter.generateStyle(ir);
    expect(adapter.getCollectedRules().size).toBeGreaterThan(0);
    adapter.reset();
    expect(adapter.getCollectedRules().size).toBe(0);
  });
});
